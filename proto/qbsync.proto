syntax = "proto3";

package qbsync;

option go_package = "github.com/arsac/qb-sync/proto";

// QBSyncService handles torrent synchronization between hot and cold storage.
// Cold qBittorrent is the single source of truth for sync status.
// InitTorrent determines what needs syncing by checking qB, active syncs, and filesystem.
service QBSyncService {
  // WritePiece sends a single piece to the receiver (for simple cases).
  rpc WritePiece(WritePieceRequest) returns (WritePieceResponse);

  // StreamPiecesBidi provides full-duplex streaming for maximum throughput.
  // Client streams pieces, server streams back acknowledgments as pieces are written.
  // This allows immediate retry on failure without waiting for batch completion.
  rpc StreamPiecesBidi(stream WritePieceRequest) returns (stream PieceAck);

  // InitTorrent initializes or resumes a torrent sync.
  // This is the primary entry point - it checks:
  // 1. If torrent is already complete in cold qBittorrent -> COMPLETE
  // 2. If sync is in progress -> returns remaining pieces_needed
  // 3. If files exist on disk -> triggers qB verification, returns verified pieces
  // 4. Fresh torrent -> all pieces needed
  // This RPC is idempotent - safe to call multiple times.
  rpc InitTorrent(InitTorrentRequest) returns (InitTorrentResponse);

  // CreateHardlink creates a hardlink from an existing file to a new path.
  // Used when source files are hardlinked to avoid re-sending duplicate data.
  rpc CreateHardlink(CreateHardlinkRequest) returns (CreateHardlinkResponse);

  // GetFileByInode checks if a file with the given inode has been received.
  // Returns the path if found, allowing the sender to use CreateHardlink.
  rpc GetFileByInode(GetFileByInodeRequest) returns (GetFileByInodeResponse);

  // RegisterFile registers a completed file's inode for hardlink tracking.
  rpc RegisterFile(RegisterFileRequest) returns (RegisterFileResponse);

  // FinalizeTorrent completes torrent transfer: renames partial files,
  // adds to local qBittorrent, triggers recheck, and waits for verification.
  rpc FinalizeTorrent(FinalizeTorrentRequest) returns (FinalizeTorrentResponse);

  // AbortTorrent aborts an in-progress torrent transfer and cleans up partial files.
  // Called when a torrent is removed from hot before streaming completes.
  rpc AbortTorrent(AbortTorrentRequest) returns (AbortTorrentResponse);

  // StartTorrent resumes a stopped torrent on cold qBittorrent.
  // Called by hot during disk pressure cleanup after stopping the torrent on hot,
  // ensuring cold takes over seeding before hot deletes the torrent.
  rpc StartTorrent(StartTorrentRequest) returns (StartTorrentResponse);
}

// PieceErrorCode categorizes piece-level failures for retry decisions.
enum PieceErrorCode {
  PIECE_ERROR_NONE = 0;            // Default / unknown (backward-compatible with old cold)
  PIECE_ERROR_IO = 1;              // Disk I/O, permission, disk full
  PIECE_ERROR_HASH_MISMATCH = 2;   // SHA1 verification failed
  PIECE_ERROR_NOT_INITIALIZED = 3; // Torrent not tracked on cold
  PIECE_ERROR_FINALIZING = 4;      // Torrent is being finalized
}

message WritePieceRequest {
  string torrent_hash = 1;
  int32 piece_index = 2;
  int64 offset = 3;
  int64 size = 4;
  string piece_hash = 5;  // SHA1 hash for verification
  bytes data = 6;
}

message WritePieceResponse {
  bool success = 1;
  string error = 2;
  PieceErrorCode error_code = 3;
}

// PieceAck is sent by the receiver for each piece in bidirectional streaming.
message PieceAck {
  string torrent_hash = 1;
  int32 piece_index = 2;
  bool success = 3;
  string error = 4;
  PieceErrorCode error_code = 5;  // Structured error code for retry decisions
}

message InitTorrentRequest {
  string torrent_hash = 1;
  string name = 2;
  int64 piece_size = 3;
  int64 total_size = 4;
  int32 num_pieces = 5;
  repeated FileInfo files = 6;
  bytes torrent_file = 7;           // Raw .torrent file for resume state and verification
  repeated string piece_hashes = 8; // SHA1 hashes per piece (hex-encoded)
}

message FileInfo {
  string path = 1;
  int64 size = 2;
  int64 offset = 3;
  uint64 inode = 4;  // Source filesystem inode for hardlink detection
}

// TorrentSyncStatus indicates the current state of a torrent on cold.
enum TorrentSyncStatus {
  // READY: Torrent initialized, stream pieces where pieces_needed[i] is true.
  // If all pieces_needed are false, just call FinalizeTorrent.
  SYNC_STATUS_READY = 0;

  // COMPLETE: Torrent already exists in cold qBittorrent and is verified.
  // No action needed - hot can delete this torrent if space is needed.
  SYNC_STATUS_COMPLETE = 1;

  // VERIFYING: Files exist on disk, qBittorrent recheck is in progress.
  // Hot should wait and retry InitTorrent after a delay.
  SYNC_STATUS_VERIFYING = 2;
}

message InitTorrentResponse {
  bool success = 1;
  string error = 2;

  // Status indicates what action hot should take
  TorrentSyncStatus status = 3;

  // pieces_needed[i] = true means piece i needs to be streamed.
  // Only populated when status is SYNC_STATUS_READY.
  // Empty if status is SYNC_STATUS_COMPLETE or SYNC_STATUS_VERIFYING.
  repeated bool pieces_needed = 4;

  // Hardlink results - which files were hardlinked (for logging/debugging)
  repeated HardlinkResult hardlink_results = 5;

  // Count of pieces that need streaming (convenience field)
  int32 pieces_needed_count = 6;

  // Count of pieces already present (hardlinked, verified, or previously received)
  int32 pieces_have_count = 7;
}

// HardlinkResult describes the result of hardlink detection for a single file.
message HardlinkResult {
  int32 file_index = 1;        // Index in files array
  bool hardlinked = 2;         // Whether hardlink was created
  string source_path = 3;      // Path of existing file used (if hardlinked)
  string error = 4;            // Error message if hardlink failed
  bool pending = 5;            // Waiting for another torrent to finish this file
  bool pre_existing = 6;       // File already existed on disk with correct size
}

// Hardlink support messages

message CreateHardlinkRequest {
  // Source file path (relative to base path) that already exists on receiver
  string source_path = 1;
  // Target file path (relative to base path) to create as hardlink
  string target_path = 2;
}

message CreateHardlinkResponse {
  bool success = 1;
  string error = 2;
}

message GetFileByInodeRequest {
  // Inode from the source filesystem (used as unique file identifier)
  uint64 inode = 1;
}

message GetFileByInodeResponse {
  // Whether a file with this inode has been registered
  bool found = 1;
  // Path to the existing file (relative to base path) if found
  string path = 2;
}

message RegisterFileRequest {
  // Inode from the source filesystem
  uint64 inode = 1;
  // Path where the file was written (relative to base path)
  string path = 2;
  // File size for verification
  int64 size = 3;
}

message RegisterFileResponse {
  bool success = 1;
  string error = 2;
}

message FinalizeTorrentRequest {
  string torrent_hash = 1;
  string save_path = 2;    // Destination path for qBittorrent
  string category = 3;     // Optional category
  string tags = 4;         // Optional tags (comma-separated)
}

message FinalizeTorrentResponse {
  bool success = 1;
  string error = 2;
  string state = 3;        // Final qBittorrent state
}

message AbortTorrentRequest {
  string torrent_hash = 1;
  bool delete_files = 2;   // If true, delete partial files; if false, just stop tracking
}

message AbortTorrentResponse {
  bool success = 1;
  string error = 2;
  int32 files_deleted = 3; // Number of partial files deleted
}

message StartTorrentRequest {
  string torrent_hash = 1;
}

message StartTorrentResponse {
  bool success = 1;
  string error = 2;
}

// Piece is a lightweight reference to a piece (no data).
// Used for internal signaling/queueing between hot components.
message Piece {
  string torrent_hash = 1;
  int32 index = 2;
  int64 offset = 3;
  int64 size = 4;
  string hash = 5;  // SHA1 hash for verification
}
