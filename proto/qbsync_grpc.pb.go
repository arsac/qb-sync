// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             (unknown)
// source: qbsync.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	QBSyncService_WritePiece_FullMethodName       = "/qbsync.QBSyncService/WritePiece"
	QBSyncService_StreamPiecesBidi_FullMethodName = "/qbsync.QBSyncService/StreamPiecesBidi"
	QBSyncService_GetWrittenPieces_FullMethodName = "/qbsync.QBSyncService/GetWrittenPieces"
	QBSyncService_InitTorrent_FullMethodName      = "/qbsync.QBSyncService/InitTorrent"
	QBSyncService_CreateHardlink_FullMethodName   = "/qbsync.QBSyncService/CreateHardlink"
	QBSyncService_GetFileByInode_FullMethodName   = "/qbsync.QBSyncService/GetFileByInode"
	QBSyncService_RegisterFile_FullMethodName     = "/qbsync.QBSyncService/RegisterFile"
	QBSyncService_FinalizeTorrent_FullMethodName  = "/qbsync.QBSyncService/FinalizeTorrent"
	QBSyncService_AbortTorrent_FullMethodName     = "/qbsync.QBSyncService/AbortTorrent"
)

// QBSyncServiceClient is the client API for QBSyncService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// QBSyncService handles torrent synchronization between hot and cold storage.
// It manages the full lifecycle: initialization, piece transfer,
// hardlink deduplication, and finalization.
type QBSyncServiceClient interface {
	// WritePiece sends a single piece to the receiver (for simple cases).
	WritePiece(ctx context.Context, in *WritePieceRequest, opts ...grpc.CallOption) (*WritePieceResponse, error)
	// StreamPiecesBidi provides full-duplex streaming for maximum throughput.
	// Client streams pieces, server streams back acknowledgments as pieces are written.
	// This allows immediate retry on failure without waiting for batch completion.
	StreamPiecesBidi(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[WritePieceRequest, PieceAck], error)
	// GetWrittenPieces returns which pieces have been written for a torrent.
	GetWrittenPieces(ctx context.Context, in *GetWrittenPiecesRequest, opts ...grpc.CallOption) (*GetWrittenPiecesResponse, error)
	// InitTorrent initializes tracking for a new torrent.
	InitTorrent(ctx context.Context, in *InitTorrentRequest, opts ...grpc.CallOption) (*InitTorrentResponse, error)
	// CreateHardlink creates a hardlink from an existing file to a new path.
	// Used when source files are hardlinked to avoid re-sending duplicate data.
	CreateHardlink(ctx context.Context, in *CreateHardlinkRequest, opts ...grpc.CallOption) (*CreateHardlinkResponse, error)
	// GetFileByInode checks if a file with the given inode has been received.
	// Returns the path if found, allowing the sender to use CreateHardlink.
	GetFileByInode(ctx context.Context, in *GetFileByInodeRequest, opts ...grpc.CallOption) (*GetFileByInodeResponse, error)
	// RegisterFile registers a completed file's inode for hardlink tracking.
	RegisterFile(ctx context.Context, in *RegisterFileRequest, opts ...grpc.CallOption) (*RegisterFileResponse, error)
	// FinalizeTorrent completes torrent transfer: renames partial files,
	// adds to local qBittorrent, triggers recheck, and waits for verification.
	FinalizeTorrent(ctx context.Context, in *FinalizeTorrentRequest, opts ...grpc.CallOption) (*FinalizeTorrentResponse, error)
	// AbortTorrent aborts an in-progress torrent transfer and cleans up partial files.
	// Called when a torrent is removed from hot before streaming completes.
	AbortTorrent(ctx context.Context, in *AbortTorrentRequest, opts ...grpc.CallOption) (*AbortTorrentResponse, error)
}

type qBSyncServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewQBSyncServiceClient(cc grpc.ClientConnInterface) QBSyncServiceClient {
	return &qBSyncServiceClient{cc}
}

func (c *qBSyncServiceClient) WritePiece(ctx context.Context, in *WritePieceRequest, opts ...grpc.CallOption) (*WritePieceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WritePieceResponse)
	err := c.cc.Invoke(ctx, QBSyncService_WritePiece_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qBSyncServiceClient) StreamPiecesBidi(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[WritePieceRequest, PieceAck], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &QBSyncService_ServiceDesc.Streams[0], QBSyncService_StreamPiecesBidi_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WritePieceRequest, PieceAck]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type QBSyncService_StreamPiecesBidiClient = grpc.BidiStreamingClient[WritePieceRequest, PieceAck]

func (c *qBSyncServiceClient) GetWrittenPieces(ctx context.Context, in *GetWrittenPiecesRequest, opts ...grpc.CallOption) (*GetWrittenPiecesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetWrittenPiecesResponse)
	err := c.cc.Invoke(ctx, QBSyncService_GetWrittenPieces_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qBSyncServiceClient) InitTorrent(ctx context.Context, in *InitTorrentRequest, opts ...grpc.CallOption) (*InitTorrentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(InitTorrentResponse)
	err := c.cc.Invoke(ctx, QBSyncService_InitTorrent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qBSyncServiceClient) CreateHardlink(ctx context.Context, in *CreateHardlinkRequest, opts ...grpc.CallOption) (*CreateHardlinkResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateHardlinkResponse)
	err := c.cc.Invoke(ctx, QBSyncService_CreateHardlink_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qBSyncServiceClient) GetFileByInode(ctx context.Context, in *GetFileByInodeRequest, opts ...grpc.CallOption) (*GetFileByInodeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetFileByInodeResponse)
	err := c.cc.Invoke(ctx, QBSyncService_GetFileByInode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qBSyncServiceClient) RegisterFile(ctx context.Context, in *RegisterFileRequest, opts ...grpc.CallOption) (*RegisterFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterFileResponse)
	err := c.cc.Invoke(ctx, QBSyncService_RegisterFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qBSyncServiceClient) FinalizeTorrent(ctx context.Context, in *FinalizeTorrentRequest, opts ...grpc.CallOption) (*FinalizeTorrentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FinalizeTorrentResponse)
	err := c.cc.Invoke(ctx, QBSyncService_FinalizeTorrent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *qBSyncServiceClient) AbortTorrent(ctx context.Context, in *AbortTorrentRequest, opts ...grpc.CallOption) (*AbortTorrentResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AbortTorrentResponse)
	err := c.cc.Invoke(ctx, QBSyncService_AbortTorrent_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QBSyncServiceServer is the server API for QBSyncService service.
// All implementations must embed UnimplementedQBSyncServiceServer
// for forward compatibility.
//
// QBSyncService handles torrent synchronization between hot and cold storage.
// It manages the full lifecycle: initialization, piece transfer,
// hardlink deduplication, and finalization.
type QBSyncServiceServer interface {
	// WritePiece sends a single piece to the receiver (for simple cases).
	WritePiece(context.Context, *WritePieceRequest) (*WritePieceResponse, error)
	// StreamPiecesBidi provides full-duplex streaming for maximum throughput.
	// Client streams pieces, server streams back acknowledgments as pieces are written.
	// This allows immediate retry on failure without waiting for batch completion.
	StreamPiecesBidi(grpc.BidiStreamingServer[WritePieceRequest, PieceAck]) error
	// GetWrittenPieces returns which pieces have been written for a torrent.
	GetWrittenPieces(context.Context, *GetWrittenPiecesRequest) (*GetWrittenPiecesResponse, error)
	// InitTorrent initializes tracking for a new torrent.
	InitTorrent(context.Context, *InitTorrentRequest) (*InitTorrentResponse, error)
	// CreateHardlink creates a hardlink from an existing file to a new path.
	// Used when source files are hardlinked to avoid re-sending duplicate data.
	CreateHardlink(context.Context, *CreateHardlinkRequest) (*CreateHardlinkResponse, error)
	// GetFileByInode checks if a file with the given inode has been received.
	// Returns the path if found, allowing the sender to use CreateHardlink.
	GetFileByInode(context.Context, *GetFileByInodeRequest) (*GetFileByInodeResponse, error)
	// RegisterFile registers a completed file's inode for hardlink tracking.
	RegisterFile(context.Context, *RegisterFileRequest) (*RegisterFileResponse, error)
	// FinalizeTorrent completes torrent transfer: renames partial files,
	// adds to local qBittorrent, triggers recheck, and waits for verification.
	FinalizeTorrent(context.Context, *FinalizeTorrentRequest) (*FinalizeTorrentResponse, error)
	// AbortTorrent aborts an in-progress torrent transfer and cleans up partial files.
	// Called when a torrent is removed from hot before streaming completes.
	AbortTorrent(context.Context, *AbortTorrentRequest) (*AbortTorrentResponse, error)
	mustEmbedUnimplementedQBSyncServiceServer()
}

// UnimplementedQBSyncServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedQBSyncServiceServer struct{}

func (UnimplementedQBSyncServiceServer) WritePiece(context.Context, *WritePieceRequest) (*WritePieceResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method WritePiece not implemented")
}
func (UnimplementedQBSyncServiceServer) StreamPiecesBidi(grpc.BidiStreamingServer[WritePieceRequest, PieceAck]) error {
	return status.Error(codes.Unimplemented, "method StreamPiecesBidi not implemented")
}
func (UnimplementedQBSyncServiceServer) GetWrittenPieces(context.Context, *GetWrittenPiecesRequest) (*GetWrittenPiecesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetWrittenPieces not implemented")
}
func (UnimplementedQBSyncServiceServer) InitTorrent(context.Context, *InitTorrentRequest) (*InitTorrentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method InitTorrent not implemented")
}
func (UnimplementedQBSyncServiceServer) CreateHardlink(context.Context, *CreateHardlinkRequest) (*CreateHardlinkResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateHardlink not implemented")
}
func (UnimplementedQBSyncServiceServer) GetFileByInode(context.Context, *GetFileByInodeRequest) (*GetFileByInodeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetFileByInode not implemented")
}
func (UnimplementedQBSyncServiceServer) RegisterFile(context.Context, *RegisterFileRequest) (*RegisterFileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterFile not implemented")
}
func (UnimplementedQBSyncServiceServer) FinalizeTorrent(context.Context, *FinalizeTorrentRequest) (*FinalizeTorrentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method FinalizeTorrent not implemented")
}
func (UnimplementedQBSyncServiceServer) AbortTorrent(context.Context, *AbortTorrentRequest) (*AbortTorrentResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AbortTorrent not implemented")
}
func (UnimplementedQBSyncServiceServer) mustEmbedUnimplementedQBSyncServiceServer() {}
func (UnimplementedQBSyncServiceServer) testEmbeddedByValue()                       {}

// UnsafeQBSyncServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to QBSyncServiceServer will
// result in compilation errors.
type UnsafeQBSyncServiceServer interface {
	mustEmbedUnimplementedQBSyncServiceServer()
}

func RegisterQBSyncServiceServer(s grpc.ServiceRegistrar, srv QBSyncServiceServer) {
	// If the following call panics, it indicates UnimplementedQBSyncServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&QBSyncService_ServiceDesc, srv)
}

func _QBSyncService_WritePiece_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WritePieceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QBSyncServiceServer).WritePiece(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QBSyncService_WritePiece_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QBSyncServiceServer).WritePiece(ctx, req.(*WritePieceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QBSyncService_StreamPiecesBidi_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(QBSyncServiceServer).StreamPiecesBidi(&grpc.GenericServerStream[WritePieceRequest, PieceAck]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type QBSyncService_StreamPiecesBidiServer = grpc.BidiStreamingServer[WritePieceRequest, PieceAck]

func _QBSyncService_GetWrittenPieces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWrittenPiecesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QBSyncServiceServer).GetWrittenPieces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QBSyncService_GetWrittenPieces_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QBSyncServiceServer).GetWrittenPieces(ctx, req.(*GetWrittenPiecesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QBSyncService_InitTorrent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitTorrentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QBSyncServiceServer).InitTorrent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QBSyncService_InitTorrent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QBSyncServiceServer).InitTorrent(ctx, req.(*InitTorrentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QBSyncService_CreateHardlink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateHardlinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QBSyncServiceServer).CreateHardlink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QBSyncService_CreateHardlink_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QBSyncServiceServer).CreateHardlink(ctx, req.(*CreateHardlinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QBSyncService_GetFileByInode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFileByInodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QBSyncServiceServer).GetFileByInode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QBSyncService_GetFileByInode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QBSyncServiceServer).GetFileByInode(ctx, req.(*GetFileByInodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QBSyncService_RegisterFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QBSyncServiceServer).RegisterFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QBSyncService_RegisterFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QBSyncServiceServer).RegisterFile(ctx, req.(*RegisterFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QBSyncService_FinalizeTorrent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinalizeTorrentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QBSyncServiceServer).FinalizeTorrent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QBSyncService_FinalizeTorrent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QBSyncServiceServer).FinalizeTorrent(ctx, req.(*FinalizeTorrentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _QBSyncService_AbortTorrent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbortTorrentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QBSyncServiceServer).AbortTorrent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: QBSyncService_AbortTorrent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QBSyncServiceServer).AbortTorrent(ctx, req.(*AbortTorrentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// QBSyncService_ServiceDesc is the grpc.ServiceDesc for QBSyncService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var QBSyncService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "qbsync.QBSyncService",
	HandlerType: (*QBSyncServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "WritePiece",
			Handler:    _QBSyncService_WritePiece_Handler,
		},
		{
			MethodName: "GetWrittenPieces",
			Handler:    _QBSyncService_GetWrittenPieces_Handler,
		},
		{
			MethodName: "InitTorrent",
			Handler:    _QBSyncService_InitTorrent_Handler,
		},
		{
			MethodName: "CreateHardlink",
			Handler:    _QBSyncService_CreateHardlink_Handler,
		},
		{
			MethodName: "GetFileByInode",
			Handler:    _QBSyncService_GetFileByInode_Handler,
		},
		{
			MethodName: "RegisterFile",
			Handler:    _QBSyncService_RegisterFile_Handler,
		},
		{
			MethodName: "FinalizeTorrent",
			Handler:    _QBSyncService_FinalizeTorrent_Handler,
		},
		{
			MethodName: "AbortTorrent",
			Handler:    _QBSyncService_AbortTorrent_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamPiecesBidi",
			Handler:       _QBSyncService_StreamPiecesBidi_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "qbsync.proto",
}
